const babelParser = require('@babel/parser');
const { parseJSX } = require('./JSXParser');
const { parseBody } = require('./ExpressionParser');

class CodeGenerator {
    /**
     * Generates Babel AST based on YAML data.
     * @param {object} data - Validated YAML data.
     * @returns {object} - Babel AST object.
     */
    generateAST(data) {
        let code = "// Generated by YamlSkript\n\n";

        // Generate import statements
        code += this.generateImports(data);
        code += "\n";

        // Generate variables, objects, arrays, classes, functions, conditions, loops, exceptions, components
        code += this.generateVariables(data);
        code += this.generateObjects(data);
        code += this.generateArrays(data);
        code += this.generateClasses(data);
        code += this.generateFunctions(data);
        code += this.generateConditions(data);
        code += this.generateLoops(data);
        code += this.generateExceptions(data);
        code += this.generateComponents(data);

        // Parse the generated code into Babel AST
        const ast = babelParser.parse(code, {
            sourceType: "module",
            plugins: [
                "jsx",
                "classProperties",
                "asyncGenerators",
                "dynamicImport",
                "templateLiterals",
                "typescript"
            ]
        });

        return ast;
    }

    generateImports(data) {
        let code = "";

        // Import React and necessary hooks
        if (data.modules && data.modules.some(mod => mod.path === 'react')) {
            code += `import React, { useState, useEffect } from 'react';\n`;
        } else {
            code += `import React from 'react';\n`;
        }

        // Import additional modules
        if (data.modules && Array.isArray(data.modules)) {
            data.modules.forEach(mod => {
                if (mod.type === 'default') {
                    code += `import ${mod.alias} from '${mod.path}';\n`;
                } else if (mod.type === 'named') {
                    code += `import { ${mod.alias} } from '${mod.path}';\n`;
                }
            });
        }

        // Import CSS
        if (data.css && Array.isArray(data.css)) {
            data.css.forEach(cssFile => {
                code += `import '${cssFile}';\n`;
            });
        }

        // Handle libraries (require)
        if (data.libraries && Array.isArray(data.libraries)) {
            data.libraries.forEach(lib => {
                code += `const ${lib} = require('${lib}');\n`;
            });
        }

        return code;
    }

    generateVariables(data) {
        let code = "";

        // Handle variables
        if (data.variables && typeof data.variables === 'object') {
            Object.entries(data.variables).forEach(([varName, value]) => {
                let declarationType = 'let'; // Default declaration type

                // Identify var, const
                if (varName.startsWith('var ')) {
                    declarationType = 'var';
                    varName = varName.slice(4);
                } else if (varName.startsWith('const ')) {
                    declarationType = 'const';
                    varName = varName.slice(6);
                }

                // Handle template literals and data types
                if (typeof value === 'string') {
                    if (value.startsWith("`") && value.endsWith("`")) {
                        code += `${declarationType} ${varName} = ${value};\n`;
                    } else if (value.startsWith("function") || value.startsWith("Symbol") || value.startsWith("BigInt")) {
                        code += `${declarationType} ${varName} = ${value};\n`;
                    } else {
                        code += `${declarationType} ${varName} = "${value}";\n`;
                    }
                } else {
                    code += `${declarationType} ${varName} = ${JSON.stringify(value)};\n`;
                }
            });
            code += "\n";
        }

        return code;
    }

    generateObjects(data) {
        let code = "";

        // Handle objects
        if (data.objects && typeof data.objects === 'object') {
            Object.entries(data.objects).forEach(([objName, properties]) => {
                code += `let ${objName} = {\n`;
                Object.entries(properties).forEach(([prop, val]) => {
                    if (typeof val === 'string' && val.startsWith("function")) {
                        code += `    ${prop}: ${val},\n`;
                    } else if (typeof val === 'string' && val.startsWith('{{') && val.endsWith('}}')) {
                        // Handle dynamic expressions within objects
                        const expr = val.slice(2, -2).trim();
                        code += `    ${prop}: ${expr},\n`;
                    } else {
                        code += `    ${prop}: "${val}",\n`;
                    }
                });
                code += `};\n\n`;
            });
        }

        return code;
    }

    generateArrays(data) {
        let code = "";

        // Handle arrays
        if (data.arrays && typeof data.arrays === 'object') {
            Object.entries(data.arrays).forEach(([arrName, elements]) => {
                const processedElements = elements.map(el => {
                    if (typeof el === 'string' && el.startsWith('{{') && el.endsWith('}}')) {
                        return el.slice(2, -2).trim();
                    } else if (typeof el === 'string') {
                        return `"${el}"`;
                    }
                    return el;
                }).join(', ');
                code += `let ${arrName} = [${processedElements}];\n\n`;
            });
        }

        return code;
    }

    generateClasses(data) {
        let code = "";

        // Handle classes
        if (data.classes && Array.isArray(data.classes)) {
            data.classes.forEach(cls => {
                const extendsClause = cls.extends ? ` extends ${cls.extends}` : '';
                code += `class ${cls.name}${extendsClause} {\n`;
                if (cls.constructor) {
                    const params = cls.constructor.parameters.join(', ');
                    code += `    constructor(${params}) {\n        super(${cls.constructor.parameters.join(', ')});\n`;
                    code += parseBody(cls.constructor.body, 2);
                    code += `    }\n`;
                }
                if (cls.methods) {
                    cls.methods.forEach(method => {
                        const params = method.parameters.join(', ');
                        code += `    ${method.name}(${params}) {\n`;
                        code += parseBody(method.body, 2);
                        code += `    }\n`;
                    });
                }
                code += `}\n\n`;
            });
        }

        return code;
    }

    generateFunctions(data) {
        let code = "";

        // Handle functions
        if (data.functions && Array.isArray(data.functions)) {
            data.functions.forEach(func => {
                const asyncFlag = func.async ? 'async ' : '';
                const params = func.parameters.join(', ');
                code += `${asyncFlag}function ${func.name}(${params}) {\n`;
                if (Array.isArray(func.body)) {
                    code += parseBody(func.body, 1);
                } else {
                    code += `    ${func.body}\n`;
                }
                code += `}\n\n`;
            });
        }

        return code;
    }

    generateConditions(data) {
        let code = "";

        // Handle conditions
        if (data.conditions && Array.isArray(data.conditions)) {
            data.conditions.forEach(condition => {
                if (condition.if) {
                    code += `if (${condition.if}) {\n`;
                    if (Array.isArray(condition.execute)) {
                        code += parseBody(condition.execute, 1);
                    } else {
                        code += `    ${condition.execute}\n`;
                    }
                    code += `}`;
                }
                if (condition.else) {
                    code += ` else {\n`;
                    if (Array.isArray(condition.else.execute)) {
                        code += parseBody(condition.else.execute, 1);
                    } else {
                        code += `    ${condition.else.execute}\n`;
                    }
                    code += `}`;
                }
                code += "\n\n";
            });
        }

        return code;
    }

    generateLoops(data) {
        let code = "";

        // Handle loops
        if (data.loops && typeof data.loops === 'object') {
            if (data.loops.for) {
                const forLoop = data.loops.for;
                code += `for (${forLoop.initializer}; ${forLoop.condition}; ${forLoop.increment}) {\n`;
                if (Array.isArray(forLoop.body)) {
                    code += parseBody(forLoop.body, 1);
                } else {
                    code += `    ${forLoop.body}\n`;
                }
                code += `}\n\n`;
            }
            if (data.loops.while) {
                const whileLoop = data.loops.while;
                code += `while (${whileLoop.condition}) {\n`;
                if (Array.isArray(whileLoop.body)) {
                    code += parseBody(whileLoop.body, 1);
                } else {
                    code += `    ${whileLoop.body}\n`;
                }
                code += `}\n\n`;
            }
            if (data.loops.doWhile) {
                const doWhileLoop = data.loops.doWhile;
                code += `do {\n`;
                if (Array.isArray(doWhileLoop.body)) {
                    code += parseBody(doWhileLoop.body, 1);
                } else {
                    code += `    ${doWhileLoop.body}\n`;
                }
                code += `} while (${doWhileLoop.condition});\n\n`;
            }
        }

        return code;
    }

    generateExceptions(data) {
        let code = "";

        // Handle exceptions
        if (data.exceptions && Array.isArray(data.exceptions)) {
            data.exceptions.forEach(exception => {
                const tryBody = exception.try.body;
                const catchParam = exception.catch.parameter;
                const catchBody = exception.catch.body;
                code += `try {\n`;
                if (Array.isArray(tryBody)) {
                    code += parseBody(tryBody, 1);
                } else {
                    code += `    ${tryBody}\n`;
                }
                code += `} catch (${catchParam}) {\n`;
                if (Array.isArray(catchBody)) {
                    code += parseBody(catchBody, 1);
                } else {
                    code += `    ${catchBody}\n`;
                }
                code += `}\n\n`;
            });
        }

        return code;
    }

    generateComponents(data) {
        let code = "";

        // Handle components
        if (data.components && Array.isArray(data.components)) {
            data.components.forEach(component => {
                if (component.type === 'function') {
                    code += `export function ${component.name}() {\n`;

                    // Handle hooks
                    if (component.hooks) {
                        component.hooks.forEach(hook => {
                            if (hook.name === 'useState') {
                                const [stateVar, setStateVar] = hook.params;
                                code += `  const [${stateVar}, ${setStateVar}] = useState(${hook.initial});\n`;
                            } else if (hook.name === 'useEffect') {
                                code += `  useEffect(() => {\n    ${hook.body}\n  }, [${hook.dependencies.join(', ')}]);\n`;
                            }
                        });
                    }

                    // Handle functions within the component
                    if (component.functions && Array.isArray(component.functions)) {
                        component.functions.forEach(func => {
                            const asyncFlag = func.async ? 'async ' : '';
                            const params = func.parameters.join(', ');
                            code += `  ${asyncFlag}function ${func.name}(${params}) {\n`;
                            if (Array.isArray(func.body)) {
                                code += parseBody(func.body, 2);
                            } else {
                                code += `    ${func.body}\n`;
                            }
                            code += `  }\n\n`;
                        });
                    }

                    // Handle JSX
                    code += `  return (\n`;
                    code += parseJSX(component.jsx, 2); // Indentation level 2
                    code += `  );\n`;
                    code += `}\n\n`;
                }

                if (component.type === 'class') {
                    code += `export class ${component.name} extends React.Component {\n`;
                    code += `  constructor(props) {\n    super(props);\n    this.state = ${JSON.stringify(component.state)};\n`;
                    if (component.constructor && Array.isArray(component.constructor.body)) {
                        code += parseBody(component.constructor.body, 2);
                    }
                    code += `  }\n\n`;

                    // Handle methods
                    if (component.methods) {
                        component.methods.forEach(method => {
                            const params = method.parameters.join(', ');
                            code += `  ${method.name}(${params}) {\n`;
                            if (Array.isArray(method.body)) {
                                code += parseBody(method.body, 2);
                            } else {
                                code += `    ${method.body}\n`;
                            }
                            code += `  }\n\n`;
                        });
                    }

                    // Handle render method
                    code += `  render() {\n    return (\n`;
                    code += parseJSX(component.jsx, 4); // Indentation level 4
                    code += `    );\n  }\n`;
                    code += `}\n\n`;
                }
            });
        }

        return code;
    }
}

module.exports = CodeGenerator;